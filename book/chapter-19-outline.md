# ‡∏ö‡∏ó‡∏ó‡∏µ‡πà 19: Best Practices - Decision Guides & Migration

> ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ñ‡∏≤‡∏°‡∏ö‡πà‡∏≠‡∏¢ + ‡∏Å‡∏≤‡∏£‡∏ô‡∏≥ FP ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡∏à‡∏£‡∏¥‡∏á

---

## üéØ ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ö‡∏ó

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡πà‡∏≤‡∏ô‡∏ö‡∏ó‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ:
- **‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÑ‡∏î‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô** ‡∏ß‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡πÉ‡∏ä‡πâ Option, Either, Validation
- **‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Record ‡∏´‡∏£‡∏∑‡∏≠ Class** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EF entities ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à
- **‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡∏Ñ‡∏ß‡∏£ (‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£) ‡πÉ‡∏ä‡πâ Specifications**
- **Migrate legacy code ‚Üí FP** ‡πÅ‡∏ö‡∏ö‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≠‡∏¢‡πÑ‡∏õ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á rewrite ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- **Onboard ‡∏ó‡∏µ‡∏°** ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà FP ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏£‡∏∞‡∏ö‡∏ö
- **‡∏ô‡∏≥ FP ‡∏Ç‡∏∂‡πâ‡∏ô Production** ‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á

---

## üìö ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤

**‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: Decision Guides** (40 min) ‚≠ê‚≠ê‚≠ê
- Option vs Either vs Validation - ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡πÉ‡∏ä‡πâ‡∏≠‡∏∞‡πÑ‡∏£?
- Record vs Class for EF - trade-offs ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏π‡πâ
- When to use Specifications - complexity threshold
- Pure Functions vs Eff - where to draw the line?
- Seq vs List - lazy vs eager
- Map vs Bind - functor vs monad

**‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: Migration Strategies** (40 min) ‚≠ê‚≠ê‚≠ê
- Why NOT to rewrite everything
- Strangler Pattern - ‡∏Ñ‡πà‡∏≠‡∏¢‡πÜ ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà
- 3-Phase Migration Plan
- Legacy Integration Patterns
- Team Buy-in Strategies
- Measuring Migration Success

**‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: Team & Production** (30 min) ‚≠ê‚≠ê
- 4-Week Onboarding Plan
- Code Review Checklist
- Production Monitoring
- Common Pitfalls & Solutions

**‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 4: Reference Checklists** (10 min)
- Quick Decision Trees
- Production Readiness Checklist
- Code Quality Checklist

---

## üìñ ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡πà‡∏ß‡∏ô

---

# ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 1: Decision Guides ‚≠ê‚≠ê‚≠ê (40 ‡∏ô‡∏≤‡∏ó‡∏µ)

> ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ñ‡∏≤‡∏°‡∏ö‡πà‡∏≠‡∏¢‡∏™‡∏∏‡∏î - ‡∏ï‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà!

---

## 1.1 Option vs Either vs Validation

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ‡∏≠‡∏∞‡πÑ‡∏£?"

**Decision Tree:**

```
‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: Operation ‡∏ô‡∏µ‡πâ‡∏≠‡∏≤‡∏à fail ‡πÑ‡∏´‡∏°?
‚îÇ
‚îú‚îÄ ‡πÑ‡∏°‡πà fail ‡πÅ‡∏ï‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤ (null/not found)
‚îÇ  ‚îî‚îÄ ‡πÉ‡∏ä‡πâ Option<T>
‚îÇ     ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: getTodoById, findUser, searchProduct
‚îÇ
‚îú‚îÄ ‡∏≠‡∏≤‡∏à fail ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô 1 ‡∏≠‡∏¢‡πà‡∏≤‡∏á
‚îÇ  ‚îî‚îÄ ‡πÉ‡∏ä‡πâ Either<Error, T>
‚îÇ     ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: createTodo, updateUser, deleteProduct
‚îÇ
‚îî‚îÄ ‡∏≠‡∏≤‡∏à fail ‡∏î‡πâ‡∏ß‡∏¢‡∏´‡∏•‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏• (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ error ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)
   ‚îî‚îÄ ‡πÉ‡∏ä‡πâ Validation<Error, T>
      ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: validateDto, validateForm, businessRules
```

---

### üìä Comparison Table

| Scenario | Type | Reason | Example |
|----------|------|--------|---------|
| **‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ record ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ** | `Option<T>` | ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà error | `getTodoById(999)` |
| **Create ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à duplicate** | `Either<Error, T>` | Duplicate = error | `createUser(existing)` |
| **Validate form ‡∏´‡∏•‡∏≤‡∏¢ fields** | `Validation<Error, T>` | ‡πÅ‡∏™‡∏î‡∏á error ‡∏ó‡∏∏‡∏Å field | `validateTodo(dto)` |
| **Parse ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à invalid** | `Either<Error, T>` | Invalid = error | `parseDate("invalid")` |
| **‡∏î‡∏∂‡∏á config ‡∏ó‡∏µ‡πà optional** | `Option<T>` | ‡πÑ‡∏°‡πà‡∏°‡∏µ = ‡πÉ‡∏ä‡πâ default | `getOptionalConfig()` |
| **Login ‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î‡∏£‡∏´‡∏±‡∏™** | `Either<Error, User>` | Wrong password = error | `login(wrong)` |

---

### üíª Code Examples

#### ‚úÖ Option - Not Finding is Normal

```csharp
// ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ todo - ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà error
public static Eff<RT, Option<Todo>> getTodoById<RT>(int id)
    where RT : struct, HasTodoRepo<RT>
{
    return TodoRepo.getTodoById<RT>(id);  // Returns Option<Todo>
}

// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
var result = await TodoService.getTodoById(999).Run(runtime, ct);

result.Match(
    Some: todo => Console.WriteLine($"Found: {todo.Title}"),
    None: () => Console.WriteLine("Not found - that's OK!")  // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà error
);
```

#### ‚úÖ Either - Failure is Error

```csharp
// ‡∏™‡∏£‡πâ‡∏≤‡∏á todo - fail = error ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
public static Eff<RT, Either<Error, Todo>> createTodo<RT>(TodoCreateDto dto)
    where RT : struct, HasTodoRepo<RT>, HasUnitOfWork<RT>
{
    return from validated in validateDto(dto).ToEff()
           from todo in createEntity(validated)
           from _ in TodoRepo.addTodo<RT>(todo)
           from __ in UnitOfWork.saveChanges<RT>()
           select todo.ToEither<Error, Todo>();
}

// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
var result = await TodoService.createTodo(dto).Run(runtime, ct);

result.Match(
    Right: todo => Console.WriteLine($"Created: {todo.Id}"),
    Left: error => Console.WriteLine($"Error: {error.Message}")  // ‡πÄ‡∏õ‡πá‡∏ô error!
);
```

#### ‚úÖ Validation - Accumulate All Errors

```csharp
// Validate DTO - ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ error ‡∏ó‡∏∏‡∏Å field
public static Validation<Error, TodoCreateDto> validateDto(TodoCreateDto dto)
{
    return (
        ValidateTitle(dto.Title),
        ValidateUserId(dto.UserId),
        ValidateDueDate(dto.DueDate)
    ).Apply((title, userId, dueDate) => dto);
}

private static Validation<Error, string> ValidateTitle(string title) =>
    string.IsNullOrWhiteSpace(title)
        ? Fail<Error, string>(Error.New("TITLE_REQUIRED", "Title is required"))
        : title.Length > 200
            ? Fail<Error, string>(Error.New("TITLE_TOO_LONG", "Title max 200 chars"))
            : Success<Error, string>(title);

// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
var result = validateDto(dto);

result.Match(
    Succ: validDto => CreateTodo(validDto),
    Fail: errors => ShowErrors(errors)  // ‡πÅ‡∏™‡∏î‡∏á errors ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î!
);
```

---

### üéØ Golden Rules

**Rule 1:** ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‚â† Error ‚Üí `Option<T>`
```csharp
‚úÖ Option<User> getUserById(int id)
‚ùå Either<Error, User> getUserById(int id)  // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà error
```

**Rule 2:** ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ error message ‚Üí `Either<Error, T>`
```csharp
‚úÖ Either<Error, User> createUser(dto)
‚ùå Option<User> createUser(dto)  // ‡∏Ñ‡∏ß‡∏£‡∏ö‡∏≠‡∏Å error ‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡πÑ‡∏° fail
```

**Rule 3:** ‡∏´‡∏•‡∏≤‡∏¢ validations ‚Üí `Validation<Error, T>`
```csharp
‚úÖ Validation<Error, Dto> validateDto(dto)
‚ùå Either<Error, Dto> validateDto(dto)  // ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÅ‡∏Ñ‡πà error ‡πÅ‡∏£‡∏Å
```

---

## 1.2 Record vs Class for EF Entities

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ Record ‡∏´‡∏£‡∏∑‡∏≠ Class?"

**Decision Matrix:**

| Consideration | Record | Class | Winner |
|---------------|--------|-------|--------|
| **Immutability** | ‚úÖ Default | ‚ùå Manual | Record |
| **EF Core Support** | ‚ö†Ô∏è v5+ only, limited | ‚úÖ Full support | Class |
| **Change Tracking** | ‚ùå Difficult | ‚úÖ Built-in | Class |
| **Value Equality** | ‚úÖ Built-in | ‚ùå Manual | Record |
| **With Expressions** | ‚úÖ Built-in | ‚ùå Manual | Record |
| **No-tracking Queries** | ‚úÖ Perfect fit | ‚ö†Ô∏è Need AsNoTracking | Record |
| **Performance** | ‚úÖ Slightly faster | ‚ö†Ô∏è Tracking overhead | Record |

---

### üí° Recommended Approaches

#### Approach 1: Hybrid Class (Best for TodoApp) ‚≠ê‚≠ê‚≠ê

```csharp
// ‡πÉ‡∏ä‡πâ class ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EF + ‡πÄ‡∏û‡∏¥‡πà‡∏° immutable methods
public class Todo
{
    // Mutable properties ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EF
    public int Id { get; set; }
    public string Title { get; set; } = "";
    public bool IsCompleted { get; set; }
    public int UserId { get; set; }
    public DateTime CreatedAt { get; set; }

    // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° immutable-style methods
    public Todo WithTitle(string newTitle) =>
        new()
        {
            Id = Id,
            Title = newTitle,
            IsCompleted = IsCompleted,
            UserId = UserId,
            CreatedAt = CreatedAt
        };

    public Todo WithCompleted(bool completed) =>
        new()
        {
            Id = Id,
            Title = Title,
            IsCompleted = completed,
            UserId = UserId,
            CreatedAt = CreatedAt
        };
}

// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô immutable
var updatedTodo = existingTodo.WithTitle("New Title");

// ‡πÅ‡∏ï‡πà EF ‡∏¢‡∏±‡∏á track ‡πÑ‡∏î‡πâ‡∏õ‡∏Å‡∏ï‡∏¥
context.Todos.Update(updatedTodo);
await context.SaveChangesAsync();
```

**‡∏Ç‡πâ‡∏≠‡∏î‡∏µ:**
- ‚úÖ EF Core support ‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö
- ‚úÖ Change tracking ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥
- ‚úÖ ‡πÉ‡∏ä‡πâ immutable style ‡πÑ‡∏î‡πâ
- ‚úÖ Best of both worlds

**‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢:**
- ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô With methods ‡πÄ‡∏≠‡∏á
- ‚ö†Ô∏è ‡∏¢‡∏±‡∏á‡∏°‡∏µ public setters (‡∏≠‡∏≤‡∏à mutate ‡πÑ‡∏î‡πâ)

---

#### Approach 2: Separate Domain/Persistence Models ‚≠ê‚≠ê

```csharp
// Domain Model - immutable record (‡πÉ‡∏ä‡πâ‡πÉ‡∏ô business logic)
public record TodoDomain(
    int Id,
    string Title,
    bool IsCompleted,
    int UserId,
    DateTime CreatedAt
);

// Persistence Model - mutable class (‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö EF ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
public class TodoEntity
{
    public int Id { get; set; }
    public string Title { get; set; } = "";
    public bool IsCompleted { get; set; }
    public int UserId { get; set; }
    public DateTime CreatedAt { get; set; }

    // Mapping methods
    public TodoDomain ToDomain() =>
        new(Id, Title, IsCompleted, UserId, CreatedAt);

    public static TodoEntity FromDomain(TodoDomain todo) =>
        new()
        {
            Id = todo.Id,
            Title = todo.Title,
            IsCompleted = todo.IsCompleted,
            UserId = todo.UserId,
            CreatedAt = todo.CreatedAt
        };
}

// Repository mapping
public class LiveTodoRepository : ITodoRepository
{
    public async Task<Option<TodoDomain>> GetByIdAsync(int id, CancellationToken ct)
    {
        var entity = await _context.Todos.FindAsync(id, ct);
        return entity?.ToDomain();  // ‚úÖ Return domain model
    }

    public void Update(TodoDomain todo)
    {
        var entity = TodoEntity.FromDomain(todo);  // ‚úÖ Convert to entity
        _context.Todos.Update(entity);
    }
}
```

**‡∏Ç‡πâ‡∏≠‡∏î‡∏µ:**
- ‚úÖ Domain model 100% immutable
- ‚úÖ Clear separation of concerns
- ‚úÖ Business logic ‡πÑ‡∏°‡πà‡∏¢‡∏∏‡πà‡∏á‡∏Å‡∏±‡∏ö EF
- ‚úÖ Testable (mock domain models)

**‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢:**
- ‚ùå Mapping overhead (performance)
- ‚ùå Duplicate code (2 models)
- ‚ùå ‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡∏Å‡∏ß‡πà‡∏≤

**‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ:**
- Large domain model
- Complex business logic
- Need 100% immutability
- Multiple persistence options

---

#### Approach 3: Init-Only Properties ‚≠ê‚≠ê

```csharp
// C# 9+ init-only properties
public class Todo
{
    public int Id { get; init; }
    public string Title { get; init; } = "";
    public bool IsCompleted { get; init; }
    public int UserId { get; init; }
    public DateTime CreatedAt { get; init; }

    // ‚úÖ ‡πÉ‡∏ä‡πâ with expression ‡πÑ‡∏î‡πâ!
    // var updated = todo with { Title = "New" };
}

// EF Core 5+ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
modelBuilder.Entity<Todo>(entity =>
{
    entity.Property(e => e.Id).ValueGeneratedOnAdd();
    // Init-only properties work!
});
```

**‡∏Ç‡πâ‡∏≠‡∏î‡∏µ:**
- ‚úÖ Immutable after construction
- ‚úÖ With expressions ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ
- ‚úÖ Works with EF Core 5+

**‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢:**
- ‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á EF Core 5+
- ‚ö†Ô∏è Change tracking ‡∏ï‡πâ‡∏≠‡∏á manual
- ‚ö†Ô∏è ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ pure record

---

### üéØ Recommendation for TodoApp

**Start with Approach 1 (Hybrid Class)**

```csharp
public class Todo
{
    public int Id { get; set; }
    public string Title { get; set; } = "";
    public bool IsCompleted { get; set; }

    // Add immutable methods as needed
    public Todo WithTitle(string title) => new() { ... };
    public Todo ToggleCompleted() => new() { ... };
}
```

**Upgrade to Approach 2 if:**
- Domain becomes complex
- Need multiple persistence options
- Want 100% immutability guarantee

---

## 1.3 When to Use Specifications?

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ Specification Pattern?"

**Decision Flowchart:**

```
‡∏°‡∏µ query methods ‡∏Å‡∏µ‡πà‡∏ï‡∏±‡∏ß?
‚îÇ
‚îú‚îÄ 1-3 methods, simple
‚îÇ  ‚îî‚îÄ ‚ùå ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ Specification (over-engineering!)
‚îÇ     ‚Üí ‡πÉ‡∏ä‡πâ direct repository methods
‚îÇ
‚îú‚îÄ 4-6 methods, ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ ‡∏°‡∏µ filter combinations?
‚îÇ  ‚îÇ  ‚îú‚îÄ ‚úÖ ‡πÉ‡∏ä‡πâ Specification
‚îÇ  ‚îÇ  ‚îî‚îÄ ‚ùå Direct methods ‡∏¢‡∏±‡∏á‡∏û‡∏≠
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ reuse query logic?
‚îÇ     ‚îú‚îÄ ‚úÖ ‡πÉ‡∏ä‡πâ Specification
‚îÇ     ‚îî‚îÄ ‚ùå Direct methods OK
‚îÇ
‚îî‚îÄ 7+ methods, ‡∏°‡∏µ combinatorial explosion
   ‚îî‚îÄ ‚úÖ ‡πÉ‡∏ä‡πâ Specification (‡∏ä‡πà‡∏ß‡∏¢‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å!)
```

---

### üìä When to Use / Not Use

| Situation | Use Spec? | Why |
|-----------|-----------|-----|
| **GetById** | ‚ùå No | Too simple, over-engineering |
| **GetAll** | ‚ùå No | No filtering, direct method better |
| **GetCompleted** | ‚ùå No | Simple filter, direct method OK |
| **GetByUser** | ‚ùå No | Simple filter, direct method OK |
| **GetCompletedByUser** | ‚ö†Ô∏è Maybe | 2 filters, starting to be useful |
| **Dynamic filters (UI)** | ‚úÖ Yes! | User picks filters, perfect use case |
| **GetCompletedByUserInLastDays** | ‚úÖ Yes! | 3+ filters, composition needed |
| **Complex business rules** | ‚úÖ Yes! | Reusable, testable logic |

---

### üíª Examples

#### ‚ùå Over-Engineering (Don't Do This)

```csharp
// Too simple for Specification!
var spec = new TodoByIdSpec(id);
var todo = await repo.FindAsync(spec, ct);

// ‚ùå 10 lines of code:
// - TodoByIdSpec class (5 lines)
// - FindAsync implementation (3 lines)
// - Usage (2 lines)

// vs

// ‚úÖ 1 line:
var todo = await repo.GetByIdAsync(id, ct);
```

#### ‚úÖ Good Use Case

```csharp
// ‚úÖ Dynamic filtering based on user input
public static Eff<RT, Seq<Todo>> searchTodos<RT>(TodoSearchDto search)
    where RT : struct, HasTodoRepo<RT>
{
    // Build spec based on user choices
    var specs = Seq<Specification<Todo>>();

    if (search.UserId.HasValue)
        specs = specs.Add(TodoSpecs.ByUser(search.UserId.Value));

    if (search.CompletedOnly)
        specs = specs.Add(TodoSpecs.IsCompleted());

    if (search.LastDays.HasValue)
        specs = specs.Add(TodoSpecs.CreatedAfter(
            DateTime.Now.AddDays(-search.LastDays.Value)));

    if (search.TextSearch != null)
        specs = specs.Add(TodoSpecs.TitleContains(search.TextSearch));

    // Combine all specs
    var finalSpec = specs.Reduce((a, b) => a.And(b));

    return TodoRepo.findTodos<RT>(finalSpec);
}
```

---

### üéØ Golden Rule

**"3 Filter Rule"**

- 1-2 filters ‚Üí Direct repository method
- 3+ filters OR dynamic combinations ‚Üí Specification Pattern

**Examples:**

```csharp
// 1 filter ‚Üí Direct method ‚úÖ
public Task<List<Todo>> GetCompletedTodosAsync(ct)

// 2 filters ‚Üí Still direct method ‚úÖ
public Task<List<Todo>> GetCompletedByUserAsync(int userId, ct)

// 3+ filters ‚Üí Specification time! ‚úÖ
TodoSpecs.ByUser(id).And(IsCompleted()).And(CreatedAfter(date))

// Dynamic filters ‚Üí Specification! ‚úÖ
if (filter1) spec = spec.And(Spec1);
if (filter2) spec = spec.And(Spec2);
if (filter3) spec = spec.And(Spec3);
```

---

## 1.4 Pure Functions vs Eff Monad

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô pure function ‡∏´‡∏£‡∏∑‡∏≠ Eff?"

**Decision Rule:**

```
Function ‡∏ô‡∏µ‡πâ‡∏°‡∏µ side effects ‡πÑ‡∏´‡∏°?
‚îÇ
‚îú‚îÄ ‡πÑ‡∏°‡πà‡∏°‡∏µ (deterministic, no IO)
‚îÇ  ‚îî‚îÄ ‚úÖ Pure Function
‚îÇ     Example: validation, calculation, mapping
‚îÇ
‚îî‚îÄ ‡∏°‡∏µ (IO, database, API, random, DateTime.Now)
   ‚îî‚îÄ ‚úÖ Eff Monad
      Example: CRUD, logging, external API calls
```

---

### üìä Pure vs Eff

| Type | Pure Function | Eff Monad |
|------|---------------|-----------|
| **Input ‚Üí Output** | ‚úÖ Same input = same output | ‚ö†Ô∏è May differ |
| **Side Effects** | ‚ùå None | ‚úÖ Wrapped |
| **Testable** | ‚úÖ Super easy | ‚ö†Ô∏è Need runtime |
| **Composable** | ‚úÖ Easy | ‚úÖ Easy |
| **Performance** | ‚úÖ Fast (can cache) | ‚ö†Ô∏è IO overhead |

---

### üíª Examples

#### ‚úÖ Pure Functions

```csharp
// ‚úÖ Pure - same input = same output, no IO
public static Either<Error, Todo> validateTodo(TodoCreateDto dto)
{
    return string.IsNullOrEmpty(dto.Title)
        ? Left<Error, Todo>(Error.New("INVALID_TITLE"))
        : Right<Error, Todo>(CreateTodoFromDto(dto));
}

// ‚úÖ Pure - pure transformation
private static Todo CreateTodoFromDto(TodoCreateDto dto) =>
    new Todo
    {
        Title = dto.Title,
        UserId = dto.UserId,
        IsCompleted = false,
        CreatedAt = DateTime.UtcNow  // ‚ùå WAIT - Not pure! See below
    };

// ‚úÖ Truly pure - ‡πÉ‡∏´‡πâ caller ‡∏™‡πà‡∏á timestamp ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
private static Todo CreateTodoFromDto(TodoCreateDto dto, DateTime createdAt) =>
    new Todo
    {
        Title = dto.Title,
        UserId = dto.UserId,
        IsCompleted = false,
        CreatedAt = createdAt  // ‚úÖ Pure!
    };
```

#### ‚úÖ Eff Monad - Has Side Effects

```csharp
// ‚úÖ Eff - ‡∏°‡∏µ IO (database, logging)
public static Eff<RT, Either<Error, Todo>> createTodo<RT>(TodoCreateDto dto)
    where RT : struct,
        HasTodoRepo<RT>,
        HasUnitOfWork<RT>,
        HasLogger<RT>
{
    return from _ in LoggerIO.logInfo<RT>("Creating todo")  // IO!
           from validated in validateTodo(dto).ToEff()      // Pure
           from todo in pure(() => CreateTodoFromDto(dto, DateTime.UtcNow))  // Pure + impure datetime
           from __ in TodoRepo.addTodo<RT>(todo)           // IO!
           from ___ in UnitOfWork.saveChanges<RT>()        // IO!
           select todo.ToEither<Error, Todo>();
}
```

---

### üéØ Best Practice: Pure Sandwich

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Eff (IO)              ‚îÇ  Read from DB
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Pure Functions        ‚îÇ  Business logic
‚îÇ  - Validate            ‚îÇ  (testable!)
‚îÇ  - Calculate           ‚îÇ
‚îÇ  - Transform           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Eff (IO)              ‚îÇ  Write to DB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Example:**

```csharp
public static Eff<RT, Either<Error, Todo>> updateTodoStatus<RT>(
    int id,
    bool isCompleted)
{
    return from existingOpt in TodoRepo.getTodoById<RT>(id)  // IO
           from existing in existingOpt.ToEff(Error.New("NOT_FOUND"))

           // ‚úÖ Pure business logic
           from validated in pure(() => ValidateStatusChange(existing, isCompleted))
           from updated in pure(() => existing with { IsCompleted = isCompleted })

           from _ in TodoRepo.updateTodo<RT>(updated)  // IO
           from __ in UnitOfWork.saveChanges<RT>()    // IO
           select updated.ToEither<Error, Todo>();
}

// ‚úÖ Pure function - easy to test!
private static Either<Error, Unit> ValidateStatusChange(Todo todo, bool newStatus)
{
    if (todo.IsCompleted == newStatus)
        return Left<Error, Unit>(Error.New("NO_CHANGE", "Status already set"));

    if (todo.UserId == 0)
        return Left<Error, Unit>(Error.New("INVALID_USER", "Todo has no user"));

    return Right<Error, Unit>(unit);
}
```

---

## 1.5 Seq vs List - Lazy vs Eager

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ Seq ‡∏´‡∏£‡∏∑‡∏≠ List?"

**Quick Answer:**

- **Default: Use `Seq<T>`** (lazy, language-ext style)
- **Only use `List<T>`** when you need materialization

---

### üìä Comparison

| Aspect | Seq<T> | List<T> |
|--------|--------|---------|
| **Evaluation** | ‚úÖ Lazy | ‚ùå Eager |
| **Performance** | ‚úÖ Better for chains | ‚ö†Ô∏è Multiple enumerations |
| **Memory** | ‚úÖ Lower | ‚ö†Ô∏è Higher |
| **language-ext** | ‚úÖ Native | ‚ö†Ô∏è Convert needed |
| **LINQ** | ‚úÖ All methods | ‚úÖ All methods |

---

### üíª Examples

```csharp
// ‚ùå Eager - loads everything, multiple passes
public static Eff<RT, List<string>> getTodoTitles<RT>()
{
    return TodoRepo.getAllTodos<RT>()
        .Map(todos => todos
            .Where(t => t.IsCompleted)  // Pass 1
            .ToList()                    // Materialize
            .Select(t => t.Title)        // Pass 2
            .ToList()                    // Materialize again
            .Take(10)                    // Pass 3
            .ToList());                  // Materialize again!
}

// ‚úÖ Lazy - single pass, only evaluates what's needed
public static Eff<RT, Seq<string>> getTodoTitles<RT>()
{
    return TodoRepo.getAllTodos<RT>()
        .Map(todos => todos
            .Filter(t => t.IsCompleted)  // Not evaluated yet
            .Map(t => t.Title)            // Not evaluated yet
            .Take(10)                     // Not evaluated yet
            .ToSeq());                    // Evaluated once when needed!
}
```

---

### üéØ When to Use List

```csharp
// ‚úÖ Use List when you need:

// 1. Count without enumeration
var count = list.Count;  // O(1) vs Seq.Count O(n)

// 2. Index access
var first = list[0];  // O(1) vs Seq not supported

// 3. Multiple enumerations (already materialized)
foreach (var item in list) { }
foreach (var item in list) { }  // No re-query

// 4. EF Core requirement
context.Todos.ToList();  // Sometimes needed for EF

// Otherwise, use Seq!
```

---

## 1.6 Map vs Bind - Functor vs Monad

### ‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°: "‡πÉ‡∏ä‡πâ Map ‡∏´‡∏£‡∏∑‡∏≠ Bind?"

**Simple Rule:**

- **Map:** Transform value (T ‚Üí U)
- **Bind:** Chain effects (T ‚Üí Eff<U>)

---

### üíª Examples

```csharp
// ‚úÖ Map - simple transformation
Eff<RT, int> todoCount =
    TodoRepo.getAllTodos<RT>()
        .Map(todos => todos.Count());  // Seq<Todo> ‚Üí int

// ‚úÖ Bind - chain effects
Eff<RT, Option<User>> todoOwner =
    TodoRepo.getTodoById<RT>(id)
        .Bind(todoOpt => todoOpt.Match(
            Some: t => UserRepo.getUserById<RT>(t.UserId),  // Eff<RT, Option<User>>
            None: () => SuccessEff<RT, Option<User>>(None)
        ));

// ‚ùå Wrong - can't use Map for effect
Eff<RT, Eff<RT, Option<User>>> wrong =  // ‚ùå Nested Eff!
    TodoRepo.getTodoById<RT>(id)
        .Map(todoOpt => UserRepo.getUserById<RT>(todoOpt.UserId));  // Returns Eff

// ‚úÖ Correct - use Bind for effect
Eff<RT, Option<User>> correct =
    TodoRepo.getTodoById<RT>(id)
        .Bind(todoOpt => UserRepo.getUserById<RT>(todoOpt.UserId));
```

---

# ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 2: Migration Strategies ‚≠ê‚≠ê‚≠ê (40 ‡∏ô‡∏≤‡∏ó‡∏µ)

> ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á rewrite ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î! - ‡∏ô‡∏≥ FP ‡πÑ‡∏õ‡πÉ‡∏ä‡πâ‡πÅ‡∏ö‡∏ö‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≠‡∏¢‡πÑ‡∏õ

---

## 2.1 Why NOT to Rewrite Everything

### üö´ ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Ç‡∏≠‡∏á Big Bang Rewrite

```
Big Bang Rewrite = üí£
‚îú‚îÄ High risk - ‡∏ó‡∏≥‡∏ú‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö
‚îú‚îÄ No deliverables - ‡πÑ‡∏°‡πà‡∏°‡∏µ value ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏≤‡∏á
‚îú‚îÄ Team friction - ‡∏Ñ‡∏ô‡πÄ‡∏Å‡πà‡∏≤ vs ‡∏Ñ‡∏ô‡πÉ‡∏´‡∏°‡πà
‚îú‚îÄ BusinessÂÅú - feature development ‡∏´‡∏¢‡∏∏‡∏î
‚îî‚îÄ Likely to fail - ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏¢‡πà‡∏°‡∏≤‡∏Å

Stats:
- 70% of big rewrites fail
- Average time: 2-3x estimate
- Lost features: 30%+
- Team burnout: 90%
```

---

### ‚úÖ Incremental Migration Instead

```
Incremental = üöÄ
‚îú‚îÄ Low risk - revert ‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢
‚îú‚îÄ Continuous value - ‡∏™‡πà‡∏á feature ‡πÑ‡∏î‡πâ‡∏ï‡∏•‡∏≠‡∏î
‚îú‚îÄ Learn as you go - adjust strategy
‚îú‚îÄ Team adoption - ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏ó‡∏µ‡∏•‡∏∞‡∏ô‡πâ‡∏≠‡∏¢
‚îî‚îÄ Success rate: 80%+

Benefits:
- New features in FP (clean slate)
- Old code ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ó‡∏µ‡∏•‡∏∞‡∏ä‡∏¥‡πâ‡∏ô
- Production runs throughout
- ROI ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
```

---

## 2.2 The Strangler Pattern

### üìñ Concept

> "Gradually strangle the old system by growing the new one around it"

**Visualization:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Old System (Month 0)                   ‚îÇ
‚îÇ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚îÇ
‚îÇ  Imperative Code: 100%                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Old System (Month 3)                   ‚îÇ
‚îÇ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  ‚îÇ
‚îÇ  Imperative: 75%    FP: 25%            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Old System (Month 6)                   ‚îÇ
‚îÇ  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  ‚îÇ
‚îÇ  Imperative: 50%    FP: 50%            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  New System (Month 12)                  ‚îÇ
‚îÇ  ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë  ‚îÇ
‚îÇ  FP: 100% üéâ                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### üéØ How It Works

**Step 1: Intercept**
```csharp
// ‚úÖ Route new requests to new FP code
public async Task<IActionResult> CreateTodo(TodoDto dto)
{
    if (FeatureFlags.UseFPImplementation)
        return await CreateTodoFP(dto);  // ‚úÖ New FP code
    else
        return await CreateTodoOld(dto);  // Old code
}
```

**Step 2: Grow**
```csharp
// ‚úÖ Gradually increase FP coverage
- Week 1: CreateTodo ‚Üí FP (5% traffic)
- Week 2: UpdateTodo ‚Üí FP (10% traffic)
- Week 3: DeleteTodo ‚Üí FP (25% traffic)
- Week 4: Increase to 50% traffic
- Week 8: 100% traffic
- Week 10: Remove old code
```

**Step 3: Remove**
```csharp
// ‚úÖ Delete old code when fully migrated
public async Task<IActionResult> CreateTodo(TodoDto dto)
{
    return await CreateTodoFP(dto);  // Only FP remains!
}
```

---

## 2.3 Three-Phase Migration Plan

### Phase 1: New Features Only (Month 1-2)

**Rule: ‡πÅ‡∏ï‡∏∞‡∏Ç‡∏≠‡∏á‡πÄ‡∏Å‡πà‡∏≤‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î**

```csharp
// ‚úÖ Keep old imperative code
public class OldTodoService
{
    public async Task<Todo> CreateTodo(TodoDto dto)
    {
        // DON'T TOUCH!
        var todo = new Todo { Title = dto.Title };
        _context.Add(todo);
        await _context.SaveChangesAsync();
        return todo;
    }
}

// ‚úÖ Write new features in FP
public static class NewCommentService  // New feature!
{
    public static Eff<RT, Either<Error, Comment>> createComment<RT>(
        CommentCreateDto dto)
        where RT : struct, HasCommentRepo<RT>, HasUnitOfWork<RT>
    {
        // Pure FP from day 1!
        return from validated in validateDto(dto).ToEff()
               from comment in createEntity(validated)
               from _ in CommentRepo.addComment<RT>(comment)
               from __ in UnitOfWork.saveChanges<RT>()
               select comment.ToEither<Error, Comment>();
    }
}
```

**Benefits:**
- ‚úÖ Zero risk to existing features
- ‚úÖ Team learns FP on clean slate
- ‚úÖ Can compare old vs new approach

---

### Phase 2: Extract and Wrap (Month 3-4)

**Rule: Wrap old code in Eff, don't rewrite yet**

```csharp
// ‚úÖ Create wrapper for old service
public static class LegacyTodoService
{
    private static readonly OldTodoService _oldService = new();

    // Wrap in Eff - allows composition with new code
    public static Eff<RT, Todo> createTodoLegacy<RT>(TodoDto dto)
        where RT : struct, HasCancellationToken<RT>
    {
        return from ct in CancellationTokenIO.token<RT>()
               from todo in Eff(async () => await _oldService.CreateTodo(dto))
               select todo;
    }

    // Now can use with other FP code!
    public static Eff<RT, (Todo, Comment)> createTodoWithComment<RT>(
        TodoDto todoDto,
        CommentCreateDto commentDto)
        where RT : struct,
            HasCommentRepo<RT>,
            HasUnitOfWork<RT>,
            HasCancellationToken<RT>
    {
        return from todo in createTodoLegacy<RT>(todoDto)  // ‚úÖ Wrapped!
               from comment in NewCommentService.createComment<RT>(
                   commentDto with { TodoId = todo.Id })
               select (todo, comment);
    }
}
```

**Benefits:**
- ‚úÖ Old and new code can work together
- ‚úÖ Incremental composition
- ‚úÖ No big rewrite needed

---

### Phase 3: Gradual Refactoring (Month 5+)

**Rule: One function at a time, high-value first**

**Priority Matrix:**

| Priority | Criteria | Examples |
|----------|----------|----------|
| **High** | Frequently changed + Complex logic | CRUD, Validation |
| **Medium** | Frequently changed, Simple logic | Queries, Getters |
| **Low** | Rarely changed | Config, Utilities |
| **Never** | Stable + Working + Low value | Old reports |

**Example Refactoring:**

```csharp
// ‚ùå Old imperative code
public async Task<Todo> UpdateTodo(int id, string title)
{
    var todo = await _context.Todos.FindAsync(id);
    if (todo == null)
        throw new NotFoundException();

    todo.Title = title;  // Mutation!
    await _context.SaveChangesAsync();

    _logger.LogInformation($"Updated todo {id}");
    return todo;
}

// ‚úÖ Refactored to FP (one function)
public static Eff<RT, Either<Error, Todo>> updateTodo<RT>(
    int id,
    string title)
    where RT : struct,
        HasTodoRepo<RT>,
        HasUnitOfWork<RT>,
        HasLogger<RT>,
        HasCancellationToken<RT>
{
    return from todoOpt in TodoRepo.getTodoById<RT>(id)
           from todo in todoOpt.ToEff(Error.New("NOT_FOUND"))
           from updated in pure(() => todo with { Title = title })  // Immutable!
           from _ in TodoRepo.updateTodo<RT>(updated)
           from __ in UnitOfWork.saveChanges<RT>()
           from ___ in LoggerIO.logInfo<RT>($"Updated todo {id}")
           select updated.ToEither<Error, Todo>();
}
```

**Refactoring Schedule:**

```
Week 1: createTodo (high priority)
Week 2: updateTodo (high priority)
Week 3: deleteTodo (high priority)
Week 4: getAllTodos (medium priority)
Week 5-8: Other CRUD operations
Week 9-12: Utilities and helpers
```

---

## 2.4 Legacy Integration Patterns

### Pattern 1: Adapter Wrapper

```csharp
// ‚úÖ Wrap legacy service to implement new interface
public class LegacyTodoRepositoryAdapter : ITodoRepository
{
    private readonly OldTodoService _legacyService;

    public async Task<Option<Todo>> GetTodoByIdAsync(int id, CancellationToken ct)
    {
        try
        {
            var todo = await _legacyService.GetById(id);  // Old code
            return Option<Todo>.Some(todo);
        }
        catch (NotFoundException)
        {
            return Option<Todo>.None;  // ‚úÖ Convert exception to Option
        }
    }
}

// Use adapter in capability
public static class TodoRepo
{
    public static Eff<RT, Option<Todo>> getTodoById<RT>(int id)
        where RT : struct, HasTodoRepo<RT>, HasCancellationToken<RT>
    {
        return from repo in default(RT).TodoRepoEff  // May be adapter!
               from ct in CancellationTokenIO.token<RT>()
               from todo in Eff(() => repo.GetTodoByIdAsync(id, ct))
               select todo;
    }
}
```

---

### Pattern 2: Facade for Multiple Legacy Services

```csharp
// ‚úÖ Unified FP facade over multiple old services
public static class UnifiedTodoService
{
    public static Eff<RT, Either<Error, TodoAggregate>> getTodoAggregate<RT>(
        int id)
        where RT : struct, HasCancellationToken<RT>
    {
        return from todo in LegacyWrapper.getTodo<RT>(id)  // Old service 1
               from comments in LegacyWrapper.getComments<RT>(id)  // Old service 2
               from user in LegacyWrapper.getUser<RT>(todo.UserId)  // Old service 3
               select new TodoAggregate(todo, comments, user)
                   .ToEither<Error, TodoAggregate>();
    }

    // ‚úÖ New FP interface, delegates to old implementations
    // Can gradually replace implementations one by one
}
```

---

## 2.5 Team Buy-in Strategies

### üéØ Getting Team On Board

**Common Objections:**

| Objection | Response | Proof |
|-----------|----------|-------|
| "Too complicated" | Show simple examples first | TodoService.createTodo |
| "Not C# style" | language-ext is mature C# library | LINQ is FP! |
| "Performance?" | Show benchmarks | Often faster |
| "Learning curve steep" | Provide training plan | 4 weeks to productive |
| "We don't have time" | Start with new features only | No rewrite needed |

---

**Winning Strategy:**

**Week 1: Show, Don't Tell**
```csharp
// ‚úÖ Demo real code comparison

// Old way - 30 lines, 5 bugs
public async Task<Todo> CreateTodo(TodoDto dto) { ... }

// New way - 10 lines, 0 bugs (type safe!)
public static Eff<RT, Either<Error, Todo>> createTodo<RT>(...) { ... }

// Team sees: Less code, more safety
```

**Week 2: Pilot Project**
```
‚úÖ Pick small feature
‚úÖ Volunteer team (interested devs)
‚úÖ Pair programming sessions
‚úÖ Deliver to production
‚úÖ Measure: Bugs, time, feedback

Result: Proof that it works!
```

**Week 3: Share Success**
```
‚úÖ Demo to whole team
‚úÖ Show metrics (fewer bugs!)
‚úÖ Gather feedback
‚úÖ Address concerns
‚úÖ Plan rollout
```

**Week 4: Rollout**
```
‚úÖ Training sessions
‚úÖ Documentation
‚úÖ Code review guidelines
‚úÖ All new features in FP
‚úÖ Gradual migration plan
```

---

## 2.6 Measuring Migration Success

### üìä Metrics to Track

**Code Quality:**
```
- Bugs in FP code: ___
- Bugs in old code: ___
- Code review time: FP vs Old
- Test coverage: FP vs Old
- Mutation count: ‚Üì
```

**Team Velocity:**
```
- Time to implement feature: FP vs Old
- Time to fix bug: FP vs Old
- Onboarding time: New devs
- Refactoring safety: FP vs Old
```

**Production:**
```
- Production bugs: FP vs Old
- Performance: FP vs Old
- Error handling: Exception % ‚Üì
- Type safety: Compile errors caught
```

---

### üéØ Success Criteria

**After 3 months:**
- [ ] 25%+ new code in FP
- [ ] 50%+ team trained
- [ ] 0 production bugs in FP code
- [ ] Team velocity same or better
- [ ] Positive team feedback

**After 6 months:**
- [ ] 50%+ code in FP
- [ ] 100% team trained
- [ ] All new features in FP
- [ ] Legacy code migration started
- [ ] Proven production stability

**After 12 months:**
- [ ] 80%+ code in FP
- [ ] Legacy code mostly migrated
- [ ] Team prefers FP
- [ ] Measurable quality improvement
- [ ] Case study ready!

---

# ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 3: Team & Production ‚≠ê‚≠ê (30 ‡∏ô‡∏≤‡∏ó‡∏µ)

> ‡∏ó‡∏≥‡πÉ‡∏´‡πâ FP work ‡πÉ‡∏ô‡∏ó‡∏µ‡∏°‡πÅ‡∏•‡∏∞ production

---

## 3.1 Four-Week Onboarding Plan

### Week 1: Fundamentals

**Goal: ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à FP basics**

**Monday:**
- ‡∏≠‡πà‡∏≤‡∏ô Chapter 1-2 (Why FP, Basics)
- ‡∏î‡∏π TodoApp codebase overview
- Setup dev environment

**Tuesday-Wednesday:**
- Pure functions practice
- Immutability exercises
- Pattern matching

**Thursday:**
- Option<T> ‡πÅ‡∏•‡∏∞ Either<T>
- Match expressions
- Hands-on exercises

**Friday:**
- Quiz & review
- Pair programming with mentor
- Setup for next week

**Deliverable:** Complete 10 pure function exercises

---

### Week 2: Monads & Effects

**Goal: ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à Eff ‡πÅ‡∏•‡∏∞ monadic composition**

**Monday:**
- Eff<RT, T> monad
- Has pattern intro
- Read Chapter 4

**Tuesday-Wednesday:**
- LINQ query syntax
- Monadic binding practice
- TodoService examples

**Thursday:**
- Error handling (Either, Validation)
- Write first service function
- Code review with mentor

**Friday:**
- Validation monad exercises
- Team code review session
- Plan first real task

**Deliverable:** Write 3 service functions (with tests)

---

### Week 3: First Feature

**Goal: Implement ‡∏à‡∏£‡∏¥‡∏á**

**Monday:**
- Pick small feature (with mentor)
- Design approach
- Write specifications

**Tuesday-Thursday:**
- Implementation
- Daily stand-up with mentor
- Code reviews

**Friday:**
- Complete feature
- Tests pass
- Deploy to staging
- Retrospective

**Deliverable:** Ship first FP feature to staging! üöÄ

---

### Week 4: Independence

**Goal: Work independently**

**Monday:**
- Pick medium feature (less guidance)
- Plan and design alone
- Review with mentor

**Tuesday-Thursday:**
- Independent implementation
- Ask questions as needed
- Code review process

**Friday:**
- Feature complete
- Production deployment
- Graduation! üéâ

**Deliverable:** Ship feature to production independently

---

### üìö Learning Resources

**Week 1-2:**
- This book (Chapters 1-4)
- language-ext docs
- TodoApp code reading

**Week 3-4:**
- This book (Chapters 5-17)
- Advanced patterns
- Real PRs in codebase

**Ongoing:**
- Team wiki
- Pair programming
- Code review feedback

---

## 3.2 Code Review Checklist

### ‚úÖ FP Code Review Guide

**Print this out! Keep at desk!**

---

#### 1. Purity ‚ú®

```
- [ ] Functions are pure (same input = same output)?
- [ ] No hidden mutations?
- [ ] No global state access?
- [ ] DateTime.Now wrapped in Eff?
- [ ] Random numbers wrapped in Eff?
```

**Example:**
```csharp
// ‚ùå Not pure - hidden mutation
public static Todo UpdateTitle(Todo todo, string title)
{
    todo.Title = title;  // ‚ùå Mutation!
    return todo;
}

// ‚úÖ Pure
public static Todo UpdateTitle(Todo todo, string title) =>
    todo with { Title = title };  // ‚úÖ New instance
```

---

#### 2. Type Safety üîí

```
- [ ] Return types explicit (no var for public APIs)?
- [ ] Option<T> for nullable?
- [ ] Either<Error, T> for fallible operations?
- [ ] Validation<Error, T> for multiple errors?
- [ ] No nulls?
- [ ] No exceptions (except truly exceptional)?
```

**Example:**
```csharp
// ‚ùå Bad types
public static async Task<Todo> GetTodo(int id)  // May return null or throw
{
    var todo = await _repo.Find(id);
    if (todo == null) throw new NotFoundException();
    return todo;
}

// ‚úÖ Good types
public static Eff<RT, Option<Todo>> getTodo<RT>(int id)
    where RT : struct, HasTodoRepo<RT>
{
    return TodoRepo.getTodoById<RT>(id);  // Returns Option
}
```

---

#### 3. Naming üìù

```
- [ ] Functions: camelCase?
- [ ] Classes/Interfaces: PascalCase?
- [ ] Descriptive names?
- [ ] Type parameters clear (<RT>, <T>)?
- [ ] Error codes: UPPER_SNAKE_CASE?
```

---

#### 4. Error Handling üö®

```
- [ ] All errors handled?
- [ ] Error messages clear?
- [ ] Error codes consistent?
- [ ] No swallowed exceptions?
- [ ] Match expressions cover all cases?
```

**Example:**
```csharp
// ‚úÖ Good error handling
result.Match(
    Right: todo => ProcessTodo(todo),
    Left: error => error.Code switch
    {
        "NOT_FOUND" => NotFound(error.Message),
        "VALIDATION_ERROR" => BadRequest(error.Message),
        _ => InternalServerError(error.Message)
    }
);
```

---

#### 5. Testing üß™

```
- [ ] Unit tests for pure functions?
- [ ] Integration tests for Eff pipelines?
- [ ] Property-based tests for core logic?
- [ ] Edge cases covered?
- [ ] Test names descriptive?
```

---

#### 6. Performance ‚ö°

```
- [ ] Seq<T> for large collections (lazy)?
- [ ] No unnecessary allocations?
- [ ] Caching where appropriate?
- [ ] No N+1 queries?
```

---

## 3.3 Production Monitoring

### üìä Logging Strategy

```csharp
// ‚úÖ Structured logging with context
public static Eff<RT, Either<Error, Todo>> createTodo<RT>(
    TodoCreateDto dto)
    where RT : struct,
        HasTodoRepo<RT>,
        HasLogger<RT>,
        HasUnitOfWork<RT>
{
    return from _ in LoggerIO.logInfo<RT>(
               "Creating todo",
               new  // ‚úÖ Structured data
               {
                   UserId = dto.UserId,
                   TitleLength = dto.Title.Length,
                   Timestamp = DateTime.UtcNow
               })
           from validated in validateDto(dto).ToEff()
           from todo in createEntity(validated)
           from __ in TodoRepo.addTodo<RT>(todo)
           from ___ in UnitOfWork.saveChanges<RT>()
           from ____ in LoggerIO.logInfo<RT>(
               "Todo created successfully",
               new { TodoId = todo.Id })
           select todo.ToEither<Error, Todo>();
}
```

---

### üîç Error Tracking

```csharp
// ‚úÖ Integrate with Sentry/Application Insights
public static class ErrorTracking
{
    public static Eff<RT, Unit> trackError<RT>(Error error)
        where RT : struct, HasErrorTracker<RT>
    {
        return from tracker in default(RT).ErrorTrackerEff
               from _ in Eff(() =>
               {
                   tracker.CaptureException(new
                   {
                       ErrorCode = error.Code,
                       Message = error.Message,
                       StackTrace = error.Inner?.StackTrace,
                       Timestamp = DateTime.UtcNow
                   });
                   return unit;
               })
               select unit;
    }
}

// Use in service
var result = await TodoService.createTodo(dto)
    .MapFail(error =>
        ErrorTracking.trackError(error)  // ‚úÖ Track all errors
            .Map(_ => error))
    .Run(runtime, ct);
```

---

### üíö Health Checks

```csharp
// ‚úÖ Health check endpoint
public static Eff<RT, HealthStatus> checkHealth<RT>()
    where RT : struct, HasTodoRepo<RT>, HasDatabase<RT>
{
    return from dbPing in Database.ping<RT>()
               .MapFail(_ => false)
               .IfFail(false)
           from repoPing in TodoRepo.healthCheck<RT>()
               .MapFail(_ => false)
               .IfFail(false)
           select new HealthStatus
           {
               Database = dbPing ? "Healthy" : "Unhealthy",
               Repository = repoPing ? "Healthy" : "Unhealthy",
               Timestamp = DateTime.UtcNow
           };
}
```

---

# ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà 4: Quick Reference ‚≠ê (10 ‡∏ô‡∏≤‡∏ó‡∏µ)

> ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡∏î‡∏π‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠ - Checklists & Decision Trees

---

## 4.1 Decision Tree: Which Type to Return?

```
START: What does this function return?
‚îÇ
‚îú‚îÄ ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ (nullable)?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ Not having it is normal?
‚îÇ  ‚îÇ  ‚îî‚îÄ ‚úÖ Option<T>
‚îÇ  ‚îÇ     Example: getUserById(999) ‚Üí None (OK)
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Not having it is an error?
‚îÇ     ‚îî‚îÄ ‚úÖ Either<Error, T>
‚îÇ        Example: getRequiredConfig() ‚Üí Error
‚îÇ
‚îú‚îÄ Operation ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à fail?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ Want all errors?
‚îÇ  ‚îÇ  ‚îî‚îÄ ‚úÖ Validation<Error, T>
‚îÇ  ‚îÇ     Example: validateForm(dto) ‚Üí All field errors
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Single error is enough?
‚îÇ     ‚îî‚îÄ ‚úÖ Either<Error, T>
‚îÇ        Example: createTodo(dto) ‚Üí First error
‚îÇ
‚îî‚îÄ Always succeeds?
   ‚îî‚îÄ ‚úÖ T (plain value) or Eff<RT, T>
      Example: getCurrentUser() ‚Üí User (always logged in)
```

---

## 4.2 Production Readiness Checklist

```
## Code Quality
- [ ] All functions pure or wrapped in Eff
- [ ] No mutations
- [ ] Proper error types (Option/Either/Validation)
- [ ] Naming conventions followed
- [ ] XML documentation on public APIs

## Testing
- [ ] Unit tests for pure functions (>80% coverage)
- [ ] Integration tests for Eff pipelines
- [ ] Property-based tests for core logic
- [ ] All tests passing

## Performance
- [ ] Seq<T> for large collections
- [ ] No unnecessary allocations
- [ ] Benchmarks for critical paths
- [ ] No N+1 database queries

## Team
- [ ] Team trained on FP basics
- [ ] Code review process in place
- [ ] Documentation up to date
- [ ] Onboarding guide available

## Production
- [ ] Structured logging implemented
- [ ] Error tracking integrated
- [ ] Health check endpoints
- [ ] Monitoring dashboards
- [ ] Deployment process tested
```

---

## 4.3 Common Patterns Quick Reference

### Pattern: CRUD with Error Handling

```csharp
// Template:
public static Eff<RT, Either<Error, T>> createEntity<RT>(Dto dto)
    where RT : struct, HasRepo<RT>, HasUnitOfWork<RT>
{
    return from validated in validate(dto).ToEff()
           from entity in createEntity(validated)
           from _ in Repo.add<RT>(entity)
           from __ in UnitOfWork.saveChanges<RT>()
           select entity.ToEither<Error, T>();
}
```

### Pattern: Query with Option

```csharp
// Template:
public static Eff<RT, Option<T>> getById<RT>(int id)
    where RT : struct, HasRepo<RT>
{
    return Repo.getById<RT>(id);
}
```

### Pattern: Validation

```csharp
// Template:
public static Validation<Error, Dto> validate(Dto dto)
{
    return (
        ValidateField1(dto.Field1),
        ValidateField2(dto.Field2),
        ValidateField3(dto.Field3)
    ).Apply((f1, f2, f3) => dto);
}
```

---

## üìö Resources

**Documentation:**
- This book!
- language-ext GitHub: https://github.com/louthy/language-ext
- TodoApp wiki

**Tools:**
- VS Code + C# Dev Kit
- ReSharper (FP patterns)
- BenchmarkDotNet (performance)

**Community:**
- language-ext Discussions
- F# Slack (FP concepts)
- Team Slack channel

---

## üéØ Key Takeaways

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏≠‡πà‡∏≤‡∏ô‡∏ö‡∏ó‡∏ô‡∏µ‡πâ ‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏î‡πâ:

1. **‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÑ‡∏î‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô** ‚≠ê‚≠ê‚≠ê
   - Option vs Either vs Validation
   - Record vs Class
   - When to use Specifications

2. **Migrate ‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á** ‚≠ê‚≠ê‚≠ê
   - Strangler pattern
   - 3-phase plan
   - No big rewrite!

3. **Team ready** ‚≠ê‚≠ê
   - 4-week onboarding
   - Code review checklist
   - Production monitoring

4. **Quick reference** ‚≠ê
   - Decision trees
   - Checklists
   - Common patterns

---

## üß™ ‡πÅ‡∏ö‡∏ö‡∏ù‡∏∂‡∏Å‡∏´‡∏±‡∏î

### ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏á‡πà‡∏≤‡∏¢
1. ‡πÉ‡∏ä‡πâ Decision Tree ‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à type ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 5 functions
2. Review TodoApp code ‡∏î‡πâ‡∏ß‡∏¢ checklist
3. ‡∏™‡∏£‡πâ‡∏≤‡∏á migration plan ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö feature ‡∏´‡∏ô‡∏∂‡πà‡∏á

### ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Å‡∏•‡∏≤‡∏á
1. Implement Strangler pattern ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö legacy function
2. ‡∏™‡∏£‡πâ‡∏≤‡∏á 4-week plan ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö team ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
3. Setup production monitoring ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FP code

### ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏¢‡∏≤‡∏Å
1. Migrate legacy feature ‚Üí FP ‡πÅ‡∏ö‡∏ö incremental
2. Measure ‡πÅ‡∏•‡∏∞ report migration metrics
3. Present FP adoption plan to stakeholders

---

## üìä ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥

- **‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏Å:** ‚≠ê‚≠ê‚≠ê (‡∏Å‡∏•‡∏≤‡∏á - practical)
- **‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡πà‡∏≤‡∏ô:** ~100 ‡∏ô‡∏≤‡∏ó‡∏µ
- **‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡∏á‡∏°‡∏∑‡∏≠‡∏ó‡∏≥:** ~120 ‡∏ô‡∏≤‡∏ó‡∏µ
- **Decision guides:** 6 guides
- **Checklists:** 5 checklists
- **‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏´‡∏ô‡πâ‡∏≤:** ~18 ‡∏´‡∏ô‡πâ‡∏≤

---

**Status:** üìã Outline Ready ‚Üí ‚è≥ Ready to Write

**Focus:** Decision-heavy, migration-focused, practical reference chapter
